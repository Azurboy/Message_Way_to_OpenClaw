{
  "id": "70c9a7f2b813118c",
  "title": "The (very) old \"repaint mode\" GUI approach",
  "url": "https://utcc.utoronto.ca/~cks/space/blog/tech/RepaintModeGUI",
  "content": "<div class=\"wikitext\"><p>Today I ran across another article that talked in passing about\n\"retained mode\" versus \"immediate mode\" GUI toolkits (<a href=\"https://tritium.legal/blog/desktop\">this one</a>, <a href=\"https://lobste.rs/s/misukt/thanks_for_all_frames_rust_gui\">via</a>), and\ngave some code samples. As usual when I read about <a href=\"https://en.wikipedia.org/wiki/Immediate_mode_(computer_graphics)\">immediate mode</a>\nGUIs and see source code, I had a pause of confusion because the\ncode didn't feel right. That's because I keep confusing \"immediate\nmode\" as used here with a much older approach, which I will call\n<em>repaint mode</em> for lack of a better description.</p>\n\n<p>A modern immediate mode system generally uses double buffering; one\nbuffer is displayed while the entire window is re-drawn into the\nsecond buffer, and then the two buffers are flipped. I believe that\nmodern <a href=\"https://en.wikipedia.org/wiki/Retained_mode\">retained mode</a>\nsystems also tend to use double buffering to avoid <a href=\"https://en.wikipedia.org/wiki/Screen_tearing\">screen tearing</a> and other issues\n(and I don't know if they can do partial updates or have to re-render\nthe entire new buffer). In the old days, the idea of having two\nbuffers for your program's window was a decided luxury. You might\nnot even have one buffer and instead be drawing directly onto screen\nmemory. I'll call this <em>repaint mode</em>, because you directly repainted\nsome or all of your window any time you needed to change anything\nin it.</p>\n\n<p>You could do an immediate mode GUI without double buffering, in\nthis repaint mode, but it would typically be slow and look bad. So\ninstead people devoted a significant amount of effort to not\nrepainting everything but instead identifying what they were changing\nand repainting only it, along with any pixels from other elements\nof your window that had been '<a href=\"https://www.x.org/releases/X11R7.5/doc/damageproto/damageproto.txt\">damaged</a>' from\nprior activity. If you did do a broader repaint, you (or the OS)\ntypically set clipping regions so that you wouldn't actually touch\npixels that didn't need to be changed.</p>\n\n<p>(The OS's display system typically needed to support clipping regions\nin any situation where windows partially overlapped yours, because\nit couldn't let you write into their pixels.)</p>\n\n<p>One reason that old display systems worked this way is that <a href=\"https://utcc.utoronto.ca/~cks/space/blog/unix/XServerBackingStoreOptional\">it\nrequired as little memory as possible</a>, which was an important\nconsideration back in the day (which was more or less the 1980s to\nthe early to mid 1990s). People could optimize their repaint code\nto be efficient and do as little work as possible, but they couldn't\nmaterialize RAM that wasn't there. Today, RAM is relatively plentiful\nand we care a lot more about non-tearing, coherent updates.</p>\n\n<p>The typical code style for a repaint mode system was that many UI\nelements would normally only issue drawing commands to update or\nrepaint themselves when they were altered. If you had a slider or\na text field and its value was updated as a result of input, the\ncode would typically immediately call its repaint function, which\ncould lead to a relatively tight coupling of input handling to the\nrendering code (a coupling that I believe <a href=\"https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller\">Model-view-controller</a> was\ndesigned to break). Your system had to be capable of a full window\nrepaint, but if you wanted to look good, it wasn't a common operation.\nA corollary of this is that your code might spend a significant\namount of effort working out what was the minimal amount of repainting\nyou needed to do in order to correctly get between two states (and\nthis code could be quite complicated).</p>\n\n<p>(Some of the time this was hidden from you in widget and toolkit\ninternals, although they didn't necessarily give you minimal repaints\nas you changed widget organization. Also, because a drawing operation\nwas issued right away didn't mean that it took effect right away.\nIn X, <a href=\"https://utcc.utoronto.ca/~cks/space/blog/unix/XRenderingVsWaylandRendering\">server side drawing operations</a> might be batched up to be\nsent to the X server only when your program was about to wait for\nmore X events.)</p>\n\n<p>Because I'm used to this repaint mode style, modern immediate mode\ncode often looks weird to me. There's no event handler connections,\nno repaint triggers, and so on, but there is an explicit display\nstep. Alternately, you aren't merely configuring widgets and then\ncamping out in the toolkit's main loop, letting it handle events\nand repaints for you (the widgets approach is the classical style\nfor X applications, including PyTk applications such as <a href=\"https://utcc.utoronto.ca/~cks/space/blog/sysadmin/ToolsPyhosts\">pyhosts</a>).</p>\n\n<p>These days, I suspect that any modern toolkit that still looks like\na repaint mode system is probably doing double buffering behind the\nscenes (unless you deliberately turn that off). Drawing directly\nto what's visible right now on screen is decidedly out of fashion\nbecause of issues like <a href=\"https://en.wikipedia.org/wiki/Screen_tearing\">screen tearing</a>, and it's not how modern\ndisplay systems like <a href=\"https://en.wikipedia.org/wiki/Wayland_(protocol)\">Wayland</a> want to operate.\nI don't know if toolkits implement this with a full repaint on the\nnew buffer, or if they try to copy the old buffer to the new one\nand selectively repaint parts of it, but I suspect that the former\nworks better with modern graphics hardware.</p>\n\n<p>PS: My view is that even the widget toolkit version of repaint mode\nisn't a variation of retained mode because the philosophy was\ndifferent. The widget toolkit might batch up operations and defer\nredoing layout and repainting things until you either returned to\nits event loop or asked it to update the display, but you expected\na more or less direct coupling between your widget operations and\nrepaints. But you can see it as a continuum that leads to retained\nmode when you decouple and abstract things enough.</p>\n\n<p>(Now that I've written this down, perhaps I'll stop having that\nweird 'it's wrong somehow' reaction when I see immediate mode GUI\ncode.)</p>\n</div>\n<div> (<a href=\"https://utcc.utoronto.ca/~cks/space/blog/tech/RepaintModeGUI?showcomments#comments\">One comment</a>.) </div>"
}