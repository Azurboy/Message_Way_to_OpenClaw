{
  "id": "436d7ee34e1c7838",
  "title": "A fuzzer for the Toy Optimizer",
  "url": "https://bernsteinbear.com/blog/toy-fuzzer/?utm_source=rss",
  "content": "<p>It’s hard to get optimizers right. Even if you build up a painstaking test\nsuite by hand, you will likely miss corner cases, especially corner cases at\nthe interactions of multiple components or multiple optimization passes.</p>\n\n<p>I wanted to see if I could write a fuzzer to catch some of these bugs\nautomatically. But a fuzzer alone isn’t much use without some correctness\noracle—in this case, we want a more interesting bug than accidentally\ncrashing the optimizer. We want to see if the optimizer introduces a\ncorrectness bug in the program.</p>\n\n<p>So I set off in the most straightforward way possible, inspired by my\nhazy memories of a former <a href=\"https://pypy.org/posts/2024/03/fixing-bug-incremental-gc.html\">CF blog post</a>.</p>\n\n<h2 id=\"generating-programs\">Generating programs</h2>\n\n<p>Generating random programs isn’t so bad. We have program generation APIs and we\ncan dynamically pick which ones we want to call. I wrote a small loop that\ngenerates <code class=\"language-plaintext highlighter-rouge\">load</code>s from and <code class=\"language-plaintext highlighter-rouge\">store</code>s to the arguments at random offsets and with\nrandom values, and <code class=\"language-plaintext highlighter-rouge\">escape</code>s to random instructions with outputs. The idea\nwith the <code class=\"language-plaintext highlighter-rouge\">escape</code> is to keep track of the values as if there was some other\nfunction relying on them.</p>\n\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">def</span> <span class=\"nf\">generate_program</span><span class=\"p\">():</span>\n    <span class=\"n\">bb</span> <span class=\"o\">=</span> <span class=\"n\">Block</span><span class=\"p\">()</span>\n    <span class=\"n\">args</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">bb</span><span class=\"p\">.</span><span class=\"n\">getarg</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"p\">)</span> <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">)]</span>\n    <span class=\"n\">num_ops</span> <span class=\"o\">=</span> <span class=\"n\">random</span><span class=\"p\">.</span><span class=\"n\">randint</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">30</span><span class=\"p\">)</span>\n    <span class=\"n\">ops_with_values</span> <span class=\"o\">=</span> <span class=\"n\">args</span><span class=\"p\">[:]</span>\n    <span class=\"k\">for</span> <span class=\"n\">_</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"n\">num_ops</span><span class=\"p\">):</span>\n        <span class=\"n\">op</span> <span class=\"o\">=</span> <span class=\"n\">random</span><span class=\"p\">.</span><span class=\"n\">choice</span><span class=\"p\">([</span><span class=\"s\">\"load\"</span><span class=\"p\">,</span> <span class=\"s\">\"store\"</span><span class=\"p\">,</span> <span class=\"s\">\"escape\"</span><span class=\"p\">])</span>\n        <span class=\"n\">arg</span> <span class=\"o\">=</span> <span class=\"n\">random</span><span class=\"p\">.</span><span class=\"n\">choice</span><span class=\"p\">(</span><span class=\"n\">args</span><span class=\"p\">)</span>\n        <span class=\"n\">a_value</span> <span class=\"o\">=</span> <span class=\"n\">random</span><span class=\"p\">.</span><span class=\"n\">choice</span><span class=\"p\">(</span><span class=\"n\">ops_with_values</span><span class=\"p\">)</span>\n        <span class=\"n\">offset</span> <span class=\"o\">=</span> <span class=\"n\">random</span><span class=\"p\">.</span><span class=\"n\">randint</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">)</span>\n        <span class=\"k\">if</span> <span class=\"n\">op</span> <span class=\"o\">==</span> <span class=\"s\">\"load\"</span><span class=\"p\">:</span>\n            <span class=\"n\">v</span> <span class=\"o\">=</span> <span class=\"n\">bb</span><span class=\"p\">.</span><span class=\"n\">load</span><span class=\"p\">(</span><span class=\"n\">arg</span><span class=\"p\">,</span> <span class=\"n\">offset</span><span class=\"p\">)</span>\n            <span class=\"n\">ops_with_values</span><span class=\"p\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">v</span><span class=\"p\">)</span>\n        <span class=\"k\">elif</span> <span class=\"n\">op</span> <span class=\"o\">==</span> <span class=\"s\">\"store\"</span><span class=\"p\">:</span>\n            <span class=\"n\">value</span> <span class=\"o\">=</span> <span class=\"n\">random</span><span class=\"p\">.</span><span class=\"n\">randint</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">10</span><span class=\"p\">)</span>\n            <span class=\"n\">bb</span><span class=\"p\">.</span><span class=\"n\">store</span><span class=\"p\">(</span><span class=\"n\">arg</span><span class=\"p\">,</span> <span class=\"n\">offset</span><span class=\"p\">,</span> <span class=\"n\">value</span><span class=\"p\">)</span>\n        <span class=\"k\">elif</span> <span class=\"n\">op</span> <span class=\"o\">==</span> <span class=\"s\">\"escape\"</span><span class=\"p\">:</span>\n            <span class=\"n\">bb</span><span class=\"p\">.</span><span class=\"n\">escape</span><span class=\"p\">(</span><span class=\"n\">a_value</span><span class=\"p\">)</span>\n        <span class=\"k\">else</span><span class=\"p\">:</span>\n            <span class=\"k\">raise</span> <span class=\"nb\">NotImplementedError</span><span class=\"p\">(</span><span class=\"sa\">f</span><span class=\"s\">\"Unknown operation </span><span class=\"si\">{</span><span class=\"n\">op</span><span class=\"si\">}</span><span class=\"s\">\"</span><span class=\"p\">)</span>\n    <span class=\"k\">return</span> <span class=\"n\">bb</span>\n</code></pre></div></div>\n\n<p>This generates random programs. Here is an example stringified random program:</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>var0 = getarg(0)\nvar1 = getarg(1)\nvar2 = getarg(2)\nvar3 = load(var2, 0)\nvar4 = load(var0, 1)\nvar5 = load(var1, 1)\nvar6 = escape(var0)\nvar7 = store(var0, 2, 3)\nvar8 = store(var2, 0, 7)\n</code></pre></div></div>\n\n<p>No idea what would generate something like this, but oh well.</p>\n\n<h2 id=\"verifying-programs\">Verifying programs</h2>\n\n<p>Then we want to come up with our invariants. I picked the invariant that, under\nthe same preconditions, the heap will look the same after running an optimized\nprogram as it would under an un-optimized program<sup id=\"fnref:equivalence\"><a class=\"footnote\" href=\"#fn:equivalence\" rel=\"footnote\">1</a></sup>. So we can delete\ninstructions, but if we don’t have a load-bearing store, store the wrong\ninformation, or cache stale loads, we will probably catch that.</p>\n\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">def</span> <span class=\"nf\">verify_program</span><span class=\"p\">(</span><span class=\"n\">bb</span><span class=\"p\">):</span>\n    <span class=\"n\">before_no_alias</span> <span class=\"o\">=</span> <span class=\"n\">interpret_program</span><span class=\"p\">(</span><span class=\"n\">bb</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"s\">\"a\"</span><span class=\"p\">,</span> <span class=\"s\">\"b\"</span><span class=\"p\">,</span> <span class=\"s\">\"c\"</span><span class=\"p\">])</span>\n    <span class=\"n\">a</span> <span class=\"o\">=</span> <span class=\"s\">\"a\"</span>\n    <span class=\"n\">before_alias</span> <span class=\"o\">=</span> <span class=\"n\">interpret_program</span><span class=\"p\">(</span><span class=\"n\">bb</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">a</span><span class=\"p\">])</span>\n    <span class=\"n\">optimized</span> <span class=\"o\">=</span> <span class=\"n\">optimize_load_store</span><span class=\"p\">(</span><span class=\"n\">bb</span><span class=\"p\">)</span>\n    <span class=\"n\">after_no_alias</span> <span class=\"o\">=</span> <span class=\"n\">interpret_program</span><span class=\"p\">(</span><span class=\"n\">optimized</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"s\">\"a\"</span><span class=\"p\">,</span> <span class=\"s\">\"b\"</span><span class=\"p\">,</span> <span class=\"s\">\"c\"</span><span class=\"p\">])</span>\n    <span class=\"n\">after_alias</span> <span class=\"o\">=</span> <span class=\"n\">interpret_program</span><span class=\"p\">(</span><span class=\"n\">optimized</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">a</span><span class=\"p\">])</span>\n    <span class=\"k\">assert</span> <span class=\"n\">before_no_alias</span> <span class=\"o\">==</span> <span class=\"n\">after_no_alias</span>\n    <span class=\"k\">assert</span> <span class=\"n\">before_alias</span> <span class=\"o\">==</span> <span class=\"n\">after_alias</span>\n</code></pre></div></div>\n\n<p>I have a very silly verifier that tests two cases: one where the arguments do\nnot alias and one where they are all the same object. Generating partial\naliases would be a good extension here.</p>\n\n<p>Last, we have the interpreter.</p>\n\n<h2 id=\"running-programs\">Running programs</h2>\n\n<p>The interpreter is responsible for keeping track of the heap (as indexed by\n<code class=\"language-plaintext highlighter-rouge\">(object, offset)</code> pairs) as well as the results of the various instructions.</p>\n\n<p>We keep track of the <code class=\"language-plaintext highlighter-rouge\">escape</code>d values so we can see results of some\ninstructions even if they do not get written back to the heap. Maybe we should\nbe <code class=\"language-plaintext highlighter-rouge\">escape</code>ing all instructions with output instead of only random ones. Who\nknows.</p>\n\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">def</span> <span class=\"nf\">interpret_program</span><span class=\"p\">(</span><span class=\"n\">bb</span><span class=\"p\">,</span> <span class=\"n\">args</span><span class=\"p\">):</span>\n    <span class=\"n\">heap</span> <span class=\"o\">=</span> <span class=\"p\">{}</span>\n    <span class=\"n\">ssa</span> <span class=\"o\">=</span> <span class=\"p\">{}</span>\n    <span class=\"n\">escaped</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n    <span class=\"k\">for</span> <span class=\"n\">op</span> <span class=\"ow\">in</span> <span class=\"n\">bb</span><span class=\"p\">:</span>\n        <span class=\"k\">if</span> <span class=\"n\">op</span><span class=\"p\">.</span><span class=\"n\">name</span> <span class=\"o\">==</span> <span class=\"s\">\"getarg\"</span><span class=\"p\">:</span>\n            <span class=\"n\">ssa</span><span class=\"p\">[</span><span class=\"n\">op</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">args</span><span class=\"p\">[</span><span class=\"n\">get_num</span><span class=\"p\">(</span><span class=\"n\">op</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">)]</span>\n        <span class=\"k\">elif</span> <span class=\"n\">op</span><span class=\"p\">.</span><span class=\"n\">name</span> <span class=\"o\">==</span> <span class=\"s\">\"store\"</span><span class=\"p\">:</span>\n            <span class=\"n\">obj</span> <span class=\"o\">=</span> <span class=\"n\">ssa</span><span class=\"p\">[</span><span class=\"n\">op</span><span class=\"p\">.</span><span class=\"n\">arg</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">)]</span>\n            <span class=\"n\">offset</span> <span class=\"o\">=</span> <span class=\"n\">get_num</span><span class=\"p\">(</span><span class=\"n\">op</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n            <span class=\"n\">value</span> <span class=\"o\">=</span> <span class=\"n\">get_num</span><span class=\"p\">(</span><span class=\"n\">op</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">)</span>\n            <span class=\"n\">heap</span><span class=\"p\">[(</span><span class=\"n\">obj</span><span class=\"p\">,</span> <span class=\"n\">offset</span><span class=\"p\">)]</span> <span class=\"o\">=</span> <span class=\"n\">value</span>\n        <span class=\"k\">elif</span> <span class=\"n\">op</span><span class=\"p\">.</span><span class=\"n\">name</span> <span class=\"o\">==</span> <span class=\"s\">\"load\"</span><span class=\"p\">:</span>\n            <span class=\"n\">obj</span> <span class=\"o\">=</span> <span class=\"n\">ssa</span><span class=\"p\">[</span><span class=\"n\">op</span><span class=\"p\">.</span><span class=\"n\">arg</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">)]</span>\n            <span class=\"n\">offset</span> <span class=\"o\">=</span> <span class=\"n\">get_num</span><span class=\"p\">(</span><span class=\"n\">op</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n            <span class=\"n\">value</span> <span class=\"o\">=</span> <span class=\"n\">heap</span><span class=\"p\">.</span><span class=\"n\">get</span><span class=\"p\">((</span><span class=\"n\">obj</span><span class=\"p\">,</span> <span class=\"n\">offset</span><span class=\"p\">),</span> <span class=\"s\">\"unknown\"</span><span class=\"p\">)</span>\n            <span class=\"n\">ssa</span><span class=\"p\">[</span><span class=\"n\">op</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">value</span>\n        <span class=\"k\">elif</span> <span class=\"n\">op</span><span class=\"p\">.</span><span class=\"n\">name</span> <span class=\"o\">==</span> <span class=\"s\">\"escape\"</span><span class=\"p\">:</span>\n            <span class=\"n\">value</span> <span class=\"o\">=</span> <span class=\"n\">op</span><span class=\"p\">.</span><span class=\"n\">arg</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">)</span>\n            <span class=\"k\">if</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">value</span><span class=\"p\">,</span> <span class=\"n\">Constant</span><span class=\"p\">):</span>\n                <span class=\"n\">escaped</span><span class=\"p\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">value</span><span class=\"p\">.</span><span class=\"n\">value</span><span class=\"p\">)</span>\n            <span class=\"k\">else</span><span class=\"p\">:</span>\n                <span class=\"n\">escaped</span><span class=\"p\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">ssa</span><span class=\"p\">[</span><span class=\"n\">value</span><span class=\"p\">])</span>\n        <span class=\"k\">else</span><span class=\"p\">:</span>\n            <span class=\"k\">raise</span> <span class=\"nb\">NotImplementedError</span><span class=\"p\">(</span><span class=\"sa\">f</span><span class=\"s\">\"Unknown operation </span><span class=\"si\">{</span><span class=\"n\">op</span><span class=\"p\">.</span><span class=\"n\">name</span><span class=\"si\">}</span><span class=\"s\">\"</span><span class=\"p\">)</span>\n    <span class=\"n\">heap</span><span class=\"p\">[</span><span class=\"s\">\"escaped\"</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">escaped</span>\n    <span class=\"k\">return</span> <span class=\"n\">heap</span>\n</code></pre></div></div>\n\n<p>Then we return the heap so that the verifier can check.</p>\n\n<h2 id=\"the-harness\">The harness</h2>\n\n<p>Then we run a bunch of random tests through the verifier!</p>\n\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">def</span> <span class=\"nf\">test_random_programs</span><span class=\"p\">():</span>\n    <span class=\"c1\"># Remove random.seed if using in CI... instead print the seed out so you\n</span>    <span class=\"c1\"># can reproduce crashes if you find them\n</span>    <span class=\"n\">random</span><span class=\"p\">.</span><span class=\"n\">seed</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">)</span>\n    <span class=\"n\">num_programs</span> <span class=\"o\">=</span> <span class=\"mi\">100000</span>\n    <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"n\">num_programs</span><span class=\"p\">):</span>\n        <span class=\"n\">program</span> <span class=\"o\">=</span> <span class=\"n\">generate_program</span><span class=\"p\">()</span>\n        <span class=\"n\">verify_program</span><span class=\"p\">(</span><span class=\"n\">program</span><span class=\"p\">)</span>\n</code></pre></div></div>\n\n<p>The number of programs is configurable. Or you could make this <code class=\"language-plaintext highlighter-rouge\">while True</code>.\nBut due to how simple the optimizer is, we will find all the possible bugs\npretty quickly.</p>\n\n<p>I initially started writing this post because I thought I had found a bug, but\nit turns out that I had, with CF’s help, in 2022, walked through every possible\ncase in the “buggy” situation, and the optimizer handles those cases correctly.\nThat explains why the verifier didn’t find that bug!</p>\n\n<h2 id=\"testing-the-verifier\">Testing the verifier</h2>\n\n<p>So does it work? If you run it, it’ll hang for a bit and then report no issues.\nThat’s helpful, in a sense… it’s revealing that it is unable to find a\ncertain class of bug in the optimizer.</p>\n\n<p>Let’s comment out the main load-bearing pillar of correctness in the\noptimizer—removing aliasing writes—and see what happens.</p>\n\n<p>We get a crash nearly instantly:</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>$ uv run --with pytest pytest loadstore.py -k random\n...\n=========================================== FAILURES ============================================\n_____________________________________ test_random_programs ______________________________________\n\n    def test_random_programs():\n        random.seed(0)\n        num_programs = 100000\n        for i in range(num_programs):\n            program = generate_program()\n&gt;           verify_program(program)\n\nloadstore.py:617:\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nbb = [Operation(getarg, [Constant(0)], None, None), Operation(getarg, [Constant(1)], None, None), Operation(getarg, [Consta...], None, None)], None, None), Operation(load, [Operation(getarg, [Constant(0)], None, None), Constant(0)], None, None)]\n\n    def verify_program(bb):\n        before_no_alias = interpret_program(bb, [\"a\", \"b\", \"c\"])\n        a = \"a\"\n        before_alias = interpret_program(bb, [a, a, a])\n        optimized = optimize_load_store(bb)\n        after_no_alias = interpret_program(optimized, [\"a\", \"b\", \"c\"])\n        after_alias = interpret_program(optimized, [a, a, a])\n        assert before_no_alias == after_no_alias\n&gt;       assert before_alias == after_alias\nE       AssertionError: assert {('a', 0): 4,...', 3): 1, ...} == {('a', 0): 9,...', 3): 1, ...}\nE\nE         Omitting 4 identical items, use -vv to show\nE         Differing items:\nE         {('a', 0): 4} != {('a', 0): 9}\nE         Use -v to get more diff\n\nloadstore.py:610: AssertionError\n==================================== short test summary info ====================================\nFAILED loadstore.py::test_random_programs - AssertionError: assert {('a', 0): 4,...', 3): 1, ...} == {('a', 0): 9,...', 3): 1, ...}\n=============================== 1 failed, 15 deselected in 0.04s ================================\n$\n</code></pre></div></div>\n\n<p>We should probably use <code class=\"language-plaintext highlighter-rouge\">bb_to_str(bb)</code> and <code class=\"language-plaintext highlighter-rouge\">bb_to_str(optimized)</code> to print out\nthe un-optimized and optimized traces in the <code class=\"language-plaintext highlighter-rouge\">assert</code> failure messages. But we\nget a nice diff of the heap automatically, which is neat. And it points to an\naliasing problem!</p>\n\n<h2 id=\"full-code\">Full code</h2>\n\n<p>See the <a href=\"https://github.com/tekknolagi/tekknolagi.github.com/blob/fbccf9696e98721ca77c8d5ec5f828a11492b04c/loadstore.py\">full code</a>.</p>\n\n<h2 id=\"extensions\">Extensions</h2>\n\n<ul>\n  <li>Synthesize (different) types for non-aliasing objects and add them in <code class=\"language-plaintext highlighter-rouge\">info</code>\n  <!--\n    * CF notes that we could maybe do this by, instead of adding `.info`, have a\n      `checktype` guard instruction that the optimizer can use to learn types and\n      change aliasing from inside the trace\n  --></li>\n  <li>Shrink/reduce failing examples down for easier debugging</li>\n  <li>Use Hypothesis for property-based testing, which CF notes also gives you\nshrinking</li>\n  <li><a href=\"https://pypy.org/posts/2022/12/jit-bug-finding-smt-fuzzing.html\">Use Z3 to encode</a> the generated programs instead of randomly interpreting them</li>\n</ul>\n\n<h2 id=\"thanks\">Thanks</h2>\n\n<p>Thank you to <a href=\"https://cfbolz.de/\">CF Bolz-Tereick</a> for feedback on this post!</p>\n<div class=\"footnotes\">\n  <ol>\n    <li id=\"fn:equivalence\">\n      <p>CF notes that this notion of equivalence works for this\noptimizer but not for one that does allocation removal (escape analysis).\nIf we removed allocations and writes to them, we would be changing the heap\nresults and our verifier would appear to fail. This means we have to, if we\nare to delete allocations, pick a more subtle definition of equivalence.</p>\n\n      <p>Perhaps something that looks like escape analysis in the verifier’s\ninterpreter? <a class=\"reversefootnote\" href=\"#fnref:equivalence\">&#8617;</a></p>\n    </li>\n  </ol>\n</div>"
}