{"id": "9aaba21a4e557af0", "title": "Fibonacci numbers and time-space tradeoffs", "url": "https://www.johndcook.com/blog/2026/02/08/time-space-tradeoffs/", "content": "<p>A few days ago I wrote about Fibonacci numbers and <a href=\"https://www.johndcook.com/blog/2026/02/05/fibonacci-certificate/\">certificates</a>. As I pointed out in the article, there&#8217;s no need to certify Fibonacci numbers, but the point of the post was to illustrate the idea of a solution certificate in a simple context. Practical uses of certificates are more complicated.</p>\n<p>This time I want to use Fibonacci numbers to illustrate space tradeoffs. The post on Fibonacci certificates imagined providing someone a pair (<em>F</em>, <em>r</em>) where <em>F</em> is a large Fibonacci number, and <em>r</em> is a certificate proving that <em>F</em> is indeed a Fibonacci number. The goal was to minimize the computational effort to verify <em>F</em>. All the recipient needed to do was compute</p>\n<p style=\"padding-left: 40px;\"><i>|</i> 5<em>F</em>² − <em>r</em>² |.</p>\n<p>The number <em>F</em> is a Fibonacci number if and only if this number equals 4. The problem with this scenario is that <em>F</em> and <em>r</em> are both large numbers. They require transmitting and storing a lot of bits.</p>\n<p>A much more space-efficient approach would be to transmit the index of the Fibonacci number and have the user compute the number. The example in the certificate post was (12586269025, 28143753123). Since 12586269025 is the 50th Fibonacci number, I could communicate it to someone by simply transmitting the number 50. That saves space, but it puts more computational burden on the recipient.</p>\n<p>Fibonacci numbers grow exponentially with index size, and so the size of the <em>n</em>th Fibonacci number in bits is proportional to <em>n</em>. But the number of bits in <em>n</em> is proportional to log <em>n</em>. When <em>n</em> is large, the difference is dramatic.</p>\n<p>How many bits are in the 1,000,000th Fibonacci number? The <em>n</em>th Fibonacci number is φ<sup><em>n</em></sup>/√5 rounded to the nearest integer, so the number of bits in the millionth Fibonacci number would be</p>\n<p style=\"padding-left: 40px;\">log<sub>2</sub> (φ<sup>1000000</sup>/√5) = 1000000 log<sub>2</sub> φ − 0.5 log<sub>2</sub> 5</p>\n<p>which is roughly 700,000. By contrast, one million is a 20 bit number. So transmitting &#8220;1000000&#8221; is far more efficient than transmitting the millionth Fibonacci number.</p>\n<p>What does it take to compute the <em>n</em>th Fibonacci number? For small <em>n</em>, it&#8217;s fast and easy to compute the Fibonacci numbers up to <em>n</em> sequentially using the definition of the sequence. For large enough <em>n</em>, it would be faster to compute φ<sup><em>n</em></sup>/√5. However, the former requires (extended) integer arithmetic, and the latter requires (extended) floating point arithmetic. It&#8217;s not clear where the crossover point would be where floating point would be more efficient. That&#8217;s the topic of the <a href=\"https://www.johndcook.com/blog/2026/02/08/computing-large-fibonacci-numbers/\">next post</a>.</p>The post <a href=\"https://www.johndcook.com/blog/2026/02/08/time-space-tradeoffs/\">Fibonacci numbers and time-space tradeoffs</a> first appeared on <a href=\"https://www.johndcook.com/blog\">John D. Cook</a>."}