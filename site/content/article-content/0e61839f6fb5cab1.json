{
  "id": "0e61839f6fb5cab1",
  "title": "Against Query Based Compilers",
  "url": "https://matklad.github.io/2026/02/25/against-query-based-compilers.html",
  "content": "<header>\n  <h1>Against Query Based Compilers</h1>\n  <time class=\"meta\" datetime=\"2026-02-25\">Feb 25, 2026</time>\n</header>\n<p><a href=\"https://thunderseethe.dev/posts/compiler-education-deserves-a-revoluation/\">Query based compilers are all the rage</a>\nthese days, so it feels only appropriate to chart some treacherous shoals in those waters.</p>\n<p>A query-based compiler is a straightforward application of the idea of incremental computations to,\nyou guessed it, compiling. A compiler is just a simple text transformation program, implemented as a\nlot of functions. You could visualize a <em>run</em> of a compiler on a particular input source code as a\ngraph of function calls:</p>\n\n<figure>\n\n<img alt=\"\" src=\"https://matklad.github.io/assets/2026-02-25-against-query-based-compilers/1.svg\" />\n</figure>\n<p>Here, schematically, squares are inputs like file text or compiler’s command line arguments, <code>g</code> is\nan intermediate function (e.g, type checking), which is called twice, with different arguments, and\n<code>f</code> and <code>h</code> are top-level functions (compile executable, or compute completions for LSP).</p>\n<p>Looking at this picture, it’s obvious how to make our compiler “incremental” — if an input changes,\nit’s enough to re-compute only the results on path from the changed input to the root “query”:</p>\n\n<figure>\n\n<img alt=\"\" src=\"https://matklad.github.io/assets/2026-02-25-against-query-based-compilers/2.svg\" />\n</figure>\n<p>A little more thinking, and you can derive “early cutoff” optimization:</p>\n\n<figure>\n\n<img alt=\"\" src=\"https://matklad.github.io/assets/2026-02-25-against-query-based-compilers/3.svg\" />\n</figure>\n<p>If an input to the function changes, but its result doesn’t (e.g, function type is not affected by\nwhitespace change), you can stop change propagation early.</p>\n<p>And that’s … basically it. The beauty of the scheme is its silvery-bullety hue — it can be\napplied without thinking to any computation, and, with a touch of meta programming, you won’t even\nhave to change code of the compiler significantly.</p>\n<p><a href=\"https://simon.peytonjones.org/assets/pdfs/build-systems-jfp.pdf\"><em>Build Systems à la Carte</em></a> is the\ncanonical paper to read here. In a build system, a query is an opaque process whose inputs and\noutputs are file. In a query-based compiler, queries are just functions.</p>\n<hr />\n<p>The reason why we want this in the first place is incremental compilation — in IDE context\nspecifically, the compiler needs to react to a stream of tiny edits, and its time budget is about\n100ms. Big-O thinking is useful here: the time to react to the change should be proportional to the\nsize of the change, and not the overall size of the codebase. O(1) change leads to O(1) update\nof the O(N) codebase.</p>\n<p>Similar big-O thinking also demonstrates the principal limitation of the scheme — the update work\ncan’t be smaller than the change in the result.</p>\n<p>An example. Suppose our “compiler” makes a phrase upper-case:</p>\n\n<figure class=\"code-block\">\n\n\n<pre><code><span class=\"line\">compile(&quot;hello world&quot;) == &quot;HELLO WORLD&quot;</span></code></pre>\n\n</figure>\n<p>This is easy to incrementalize, as changing a few letters in the input changes only a few letters in\nthe output:</p>\n\n<figure class=\"code-block\">\n\n\n<pre><code><span class=\"line\">compile(&quot;hallo world&quot;) == &quot;HALLO WORLD&quot;</span></code></pre>\n\n</figure>\n<p>But suppose now our “compiler” is a hashing or encryption function:</p>\n\n<figure class=\"code-block\">\n\n\n<pre><code><span class=\"line\">compile(&quot;hello world&quot;) == &quot;a948904f2f0&quot;</span>\n<span class=\"line\">compile(&quot;hallo world&quot;) == &quot;a7336983eca&quot;</span></code></pre>\n\n</figure>\n<p>This is provably impossible to make usefully incremental. The encryption <em>can</em> be implemented\nas a graph of function calls, and you <em>can</em> apply the general incremental recipe to it. It just\nwon’t be very fast.</p>\n<p>The reason for that is the avalanche property — for good encryption, a change in any bit of input\nshould flip roughly half of the bits of the output. So just the work of changing the output\n(completely ignoring the work to compute what needs to be changed) is O(N), not O(1).</p>\n\n<figure class=\"blockquote\">\n<blockquote><p>The effectiveness of query-based compiler is limited by\nthe dependency structure of the source language.</p>\n</blockquote>\n\n</figure>\n<p>A particularly nasty effect here is that even if you have only <em>potential</em> avalanche, where a\ncertain kind of change <em>could</em> affect large fraction of the output, even if it usually doesn’t, your\nincremental engine likely will spend some CPU time or memory to confirm the absence of dependency.</p>\n<hr />\n<p>In my</p>\n<p><span class=\"display\"><a href=\"https://rust-analyzer.github.io/blog/2020/07/20/three-architectures-for-responsive-ide.html\"><em>Three Architectures For Responsive IDE</em></a>,</span>\nquery-based compilation is presented as a third, fall-back option. I still think that that’s\nbasically true: as a language designer, I think it’s worth listening to your inner\n<a href=\"https://grugbrain.dev\">Grug</a> and push the need for queries as far down the compilation pipeline as\npossible, sticking to more direct approaches. <em>Not</em> doing queries is simpler, faster, and simpler to\nmake faster (profiling a query-based compiler is a special genre of hurdle racing).</p>\n<p>Zig and Rust provide for a nice comparison. In Zig, every file can be parsed completely in\nisolation, so compilation starts by parsing all files independently and in parallel. Because in Zig\nevery name needs to be explicitly declared (there’s no <code>use *</code>), name resolution also can run on a\nper-file basis, without queries. Zig goes even further, and directly converts untyped AST into IR,\nemitting a whole bunch of errors in the process (e.g, “<code>var</code> doesn’t need to be mutable”). See\n<span class=\"display\"><a href=\"https://mitchellh.com/zig/astgen\"><em>Zig AstGen: AST =&gt; ZIR</em></a></span>\nfor details. By the time compiler gets to tracked queries, the data it has to work with is already\npretty far from the raw source code, but only because Zig <em>language</em> is carefully designed to allow\nthis.</p>\n<p>In contrast, you can’t really parse a file in Rust. Rust macros generate new source code, so parsing\ncan’t be finished until all the macros are expanded. Expanding macros requires name resolution,\nwhich, in Rust, is a crate-wide, rather than a file-wide operation. Its a fundamental property of\nthe language that typing something in <code>a.rs</code> can change parsing results for <code>b.rs</code>, and that forces\nfine-grained dependency tracking and invalidation to the very beginning of the front-end.</p>\n<p>Similarly, the nature of the trait system is such that <code>impl</code> blocks relevant to a particular method\ncall can be found almost anywhere. For every trait method call, you get a dependency on the <code>impl</code>\nblock that supplies the implementation, but you <em>also</em> get a dependency on non-existence of\nconflicting <code>impl</code>s in every other file!</p>\n<hr />\n<p>Another trick that becomes less available if you blindly apply queries are in-place updates.\nConsider a language with package declarations and fully qualified names, like Kotlin:</p>\n\n<figure class=\"code-block\">\n\n\n<pre><code><span class=\"line\"><span class=\"hl-keyword\">package</span> org.example</span>\n<span class=\"line\"></span>\n<span class=\"line\"><span class=\"hl-function\"><span class=\"hl-keyword\">fun</span> <span class=\"hl-title\">printMessage</span><span class=\"hl-params\">()</span></span> { <span class=\"hl-comment\">/*...*/</span> }</span>\n<span class=\"line\"><span class=\"hl-keyword\">class</span> <span class=\"hl-title class_\">Message</span> { <span class=\"hl-comment\">/*...*/</span> }</span></code></pre>\n\n</figure>\n<p>A compiler for this language probably wants to maintain a map of all public declarations, where the\nkeys are fully qualified names, and values are declarations themselves. If you approach the problem\nof computing this map with query eyes, you might have a base per-file query that returns a map of\nfile’s declarations, and then a recursive per-directory query. And you’ll probably have some kind of\nstructural sharing of the maps, such that changing a single file updates only the “spine”, without\nactually copying most of the other entries.</p>\n<p>But there’s a more direct way to make this sort of structure responsive to changes. You need only\ntwo “queries” — per file, and global. When a file changes, you look at the <em>previous</em> version of\nthe map for this file, compute a diff of added or removed declarations, and then apply this diff to\nthe global map.</p>\n<p>Zig is planning to use a similar approach to incrementalize linking — rather than producing a new\nbinary gluing mostly unchanged chunks of machine code, the idea is to in-place patch the previous\nbinary.</p>\n<hr />\n<p>If you like this article, you might be interested in some other adjacent stuff I’ve written over the\nyears, roughly in the order of importance:</p>\n<ul>\n<li>\n<a class=\"url\" href=\"https://rust-analyzer.github.io/blog/2020/07/20/three-architectures-for-responsive-ide.html\">https://rust-analyzer.github.io/blog/2020/07/20/three-architectures-for-responsive-ide.html</a>\n</li>\n<li>\n<a class=\"url\" href=\"https://rust-analyzer.github.io/blog/2023/07/24/durable-incrementality.html\">https://rust-analyzer.github.io/blog/2023/07/24/durable-incrementality.html</a>\n</li>\n<li>\n<a class=\"url\" href=\"https://matklad.github.io/2023/05/06/zig-language-server-and-cancellation.html\">https://matklad.github.io/2023/05/06/zig-language-server-and-cancellation.html</a>\n</li>\n<li>\n<a class=\"url\" href=\"https://matklad.github.io/2023/05/21/resilient-ll-parsing-tutorial.html\">https://matklad.github.io/2023/05/21/resilient-ll-parsing-tutorial.html</a>\n</li>\n<li>\n<a class=\"url\" href=\"https://rust-analyzer.github.io/blog/2019/11/13/find-usages.html\">https://rust-analyzer.github.io/blog/2019/11/13/find-usages.html</a>\n</li>\n<li>\n<a class=\"url\" href=\"https://rust-analyzer.github.io/blog/2023/12/26/the-heart-of-a-language-server.html\">https://rust-analyzer.github.io/blog/2023/12/26/the-heart-of-a-language-server.html</a>\n</li>\n<li>\n<a class=\"url\" href=\"https://rust-analyzer.github.io/blog/2020/09/28/how-to-make-a-light-bulb.html\">https://rust-analyzer.github.io/blog/2020/09/28/how-to-make-a-light-bulb.html</a>\n</li>\n<li>\n<a class=\"url\" href=\"https://matklad.github.io/2023/10/12/lsp-could-have-been-better.html\">https://matklad.github.io/2023/10/12/lsp-could-have-been-better.html</a>\n</li>\n<li>\n<a class=\"url\" href=\"https://matklad.github.io/2023/08/01/on-modularity-of-lexical-analysis.html\">https://matklad.github.io/2023/08/01/on-modularity-of-lexical-analysis.html</a>\n</li>\n<li>\n<a class=\"url\" href=\"https://matklad.github.io/2020/11/11/yde.html\">https://matklad.github.io/2020/11/11/yde.html</a>\n</li>\n</ul>"
}