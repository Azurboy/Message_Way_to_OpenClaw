{
  "id": "2d8c4da7ef32cafa",
  "title": "Testing Linux memory limits is a bit of a pain",
  "url": "https://utcc.utoronto.ca/~cks/space/blog/linux/MemoryLimitTestingPain",
  "content": "<div class=\"wikitext\"><p>For reasons outside of the scope of this entry, I want to test how\nvarious <a href=\"https://www.freedesktop.org/software/systemd/man/systemd.resource-control.html\">systemd memory resource limits</a>\nwork and interact with each other (which means that I'm really\ndigging into <a href=\"https://www.kernel.org/doc/html/latest/admin-guide/cgroup-v2.html#usage-guidelines\">cgroup v2 memory controls</a>).\nWhen I started trying to do this, it turned out that I had no good\ntest program (or programs), although I had some ones that gave me\npartial answers.</p>\n\n<p>There are two complexities in memory usage testing programs in a\ncgroups environment. First, you may be able to allocate more memory\nthan you can actually use, depending on your system's settings for\n<a href=\"https://utcc.utoronto.ca/~cks/space/blog/linux/LinuxVMOvercommit\">strict overcommit</a>. So it's not enough to see\nhow much memory you can allocate using the mechanism of your choice\n(I tend to use <a href=\"https://www.man7.org/linux/man-pages/man2/mmap.2.html\">mmap()</a> rather than\ngo through language allocators). After you've either determined how\nmuch memory you can allocate or allocated your target amount, you\nhave to at least force the kernel to materialize your memory by\nwriting something to every page of it. Since the kernel can probably\nswap out some amount of your memory, you may need to keep repeatedly\nreading all of it.</p>\n\n<p>The second issue is that if you're not in strict overcommit (and\n<a href=\"https://utcc.utoronto.ca/~cks/space/blog/linux/StrictOvercommitCanOOM\">sometimes even if you are</a>), the kernel\ncan let you allocate more memory than you can actually use and then\nyou try to use it, hit you with the OOM killer. For my testing, I\ncare about the actual usable amount of memory, not how much memory\nI can allocate, so I need to deal with this somehow (and this is\nwhere my current test programs are inadequate). Since the OOM killer\ncan't be caught by a process (that's sort of the point), the simple\napproach is probably to have my test program progressively report\non how much memory its touched so far, so I can see how far it got\nbefore it was OOM-killed. A more complex approach would be to do\nthe testing in a child process with progress reports back to the\nparent so it could try to narrow in on how much it could use rather\nthan me guessing that I wanted progress reports every, say, 16\nMBytes or 32 MBytes of memory touching.</p>\n\n<p>(Hopefully the OOM killer would only kill the child and not the\nparent, but with the OOM killer you can never be sure.)</p>\n\n<p>I'm probably not the first person to have this sort of need, so I\nsuspect that other people have written test programs and maybe even\nput them up somewhere. I don't expect to be able to find them in\ntoday's ambient Internet search noise, plus this is very close to\nthe much more popular issue of testing your RAM memory.</p>\n\n<p>(Will I put up my little test program when I hack it up? Probably\nnot, it's too much work to do it properly, with actual documentation\nand so on. And these days I'm not very enthused about putting more\nrepositories on Github, so I'd need to find some alternate place.)</p>\n</div>\n<div> (<a href=\"https://utcc.utoronto.ca/~cks/space/blog/linux/MemoryLimitTestingPain?showcomments#comments\">2 comments</a>.) </div>"
}