{
  "id": "29f1a08fd2f74d56",
  "title": "Computing big, certified Fibonacci numbers",
  "url": "https://www.johndcook.com/blog/2026/02/21/big-certified-fibonacci/",
  "content": "<p>I&#8217;ve written before about <a href=\"https://www.johndcook.com/blog/2026/02/08/computing-large-fibonacci-numbers/\">computing big Fibonacci numbers</a>, and about creating a <a href=\"https://www.johndcook.com/blog/2026/02/05/fibonacci-certificate/\">certificate</a> to verify a Fibonacci number has been calculated correctly. This post will revisit both, giving a different approach to computing big Fibonacci numbers that produces a certificate along the way.</p>\n<p>As I&#8217;ve said before, I&#8217;m not aware of any practical reason to compute large Fibonacci numbers. However, the process illustrates techniques that are practical for other problems.</p>\n<p>The fastest way to compute the <em>n</em>th Fibonacci number for sufficiently large <em>n</em> is Binet’s formula:</p>\n<p style=\"padding-left: 40px;\"><em>F</em><sub><em>n</em></sub> = round( φ<sup><em>n</em></sup> / √5 )</p>\n<p>where φ is the golden ratio. The point where <em>n</em> is &#8220;sufficiently large&#8221; depends on your hardware and software, but in my experience I found the crossover to be somewhere 1,000 and 10,000.</p>\n<p>The problem with Binet&#8217;s formula is that it requires extended precision floating point math. You need extra guard digits to make sure the integer part of your result is entirely correct. How many guard digits you&#8217;ll need isn&#8217;t obvious <em>a priori</em>. <a href=\"https://www.johndcook.com/blog/2026/02/08/computing-large-fibonacci-numbers/\">This post</a> gave a way of <em>detecting</em> errors, and it could be turned into a method for <em>correcting</em> errors.</p>\n<p>But how do we know an error didn&#8217;t slip by undetected? This question brings us back to the idea of certifying a Fibonacci number. A number <em>f</em> Fibonacci number if and only if one of 5<em>f</em><sup>2</sup> ± 4 is a perfect square.</p>\n<p>Binet&#8217;s formula, implemented in finite precision, takes a positive integer <em>n</em> and gives us a number <em>f</em> that is approximately the <em>n</em>th Fibonacci number. Even in low-precision arithmetic, the <em>relative</em> error in the computation is small. And because the ratio of consecutive Fibonacci numbers is approximately φ, an approximation to <em>F</em><sub><em>n</em></sub> is far from the Fibonacci numbers <em>F</em><sub><em>n</em> − 1</sub> and <em>F</em><sub><em>n</em> + 1</sub>. So the closest Fibonacci number to an approximation of <em>F</em><sub><em>n</em></sub> is exactly <em>F</em><sub><em>n</em></sub>.</p>\n<p>Now if <em>f</em> is approximately <em>F</em><sub><em>n</em></sub>, then 5<em>f</em><sup>2</sup> is approximately a square. Find the integer <em>r</em> minimizing  |5<em>f</em><sup>2</sup> − <em>r</em>²|. In Python you could do this with the <code>isqrt</code> function. Then either <em>r</em>² + 4 or <em>r</em>² − 4 is divisible by 5. You can know which one by looking at <em>r</em>² mod 5. Whichever one is, divide it by 5 and you have the square of <em>F</em><sub><em>n</em></sub>. You can take the square root exactly, in integer arithmetic, and you have <em>F</em><sub><em>n</em></sub>. Furthermore, the number <em>r</em> that you computed along the way is the certificate of the calculation of <em>F</em><sub><em>n</em></sub>.</p>The post <a href=\"https://www.johndcook.com/blog/2026/02/21/big-certified-fibonacci/\">Computing big, certified Fibonacci numbers</a> first appeared on <a href=\"https://www.johndcook.com/blog\">John D. Cook</a>."
}